#!/usr/bin/env python

from xlrd import open_workbook
import json
import getopt
import sys
import os

DESCRIPTOR_ROWS = 3

ROW_NOTE = 0
ROW_NAME = 1
ROW_TYPE = 2

TYPE_KEY = 'key'
TYPE_STRING = 'string'
TYPE_INT = 'int'
TYPE_FLOAT = 'float'
TYPE_BOOL = 'bool'

VALID_TYPES = {TYPE_KEY, TYPE_STRING, TYPE_INT, TYPE_FLOAT, TYPE_BOOL}

verbose = False


class Field(object):
    note = ''
    name = '__unnamed__'
    type = '__null__'

    def cs_type(self):
        if self.type == TYPE_KEY:
            return 'string'
        elif self.type == TYPE_STRING:
            return 'string'
        elif self.type == TYPE_INT:
            return 'int'
        elif self.type == TYPE_FLOAT:
            return 'float'
        elif self.type == TYPE_BOOL:
            return 'bool'
        return 'invalid-type'

    def json_type(self, value):
        if self.type == TYPE_KEY:
            return str(value)
        elif self.type == TYPE_STRING:
            return str(value)
        elif self.type == TYPE_INT:
            return float(value)
        elif self.type == TYPE_FLOAT:
            return float(value)
        elif self.type == TYPE_BOOL:
            return bool(value)
        return None


def extract_fields(sheet):
    fields = {}
    for col in range(sheet.ncols):
        type = str(sheet.cell(ROW_TYPE, col).value)
        if type in VALID_TYPES:
            field = Field()
            field.note = str(sheet.cell(ROW_NOTE, col).value)
            field.name = str(sheet.cell(ROW_NAME, col).value)
            field.type = type
            fields[col] = field

    if verbose:
        for field in fields.values():
            print field.name + ': ' + field.type + ' - ' + field.note

    return fields


def extract_elements(sheet, fields):
    elements = []
    for row in range(DESCRIPTOR_ROWS, sheet.nrows):
        element = {}
        for col in range(sheet.ncols):

            type = str(sheet.cell(ROW_TYPE, col).value)
            if type in VALID_TYPES:
                value = sheet.cell(row, col).value
                field = fields[col]
                element[field.name] = field.json_type(value)

        elements.append(element)
    return elements


def build_cs_class_constructor(class_name, fields):
    output = '\tpublic ' + class_name + '\n'
    output += '\t(\n'
    count = len(fields.values())
    for field in fields.values():
        output += '\t\t%s %s' % (field.type, field.name)
        count = count - 1
        if count > 0:
            output += ', '
        output += '\n'
    output += '\t)\n'
    output += '\t{\n'
    for field in fields.values():
        output += '\t\tthis.%s = %s;\n' % (field.name, field.name)
    output += '\t}\n'

    return output


def build_cs_class_properties(class_name, fields):
    output = ''
    for field in fields.values():
        output += '\tpublic %s %s { get; private set; }\n' % (field.type, field.name)
    return output


def build_cs_class_fields(class_name, fields):
    output = ''
    for field in fields.values():

        # don't write key types since it's derived from the base class
        if field.type in TYPE_KEY:
            continue

        output += '\t// %s\n' % field.note
        output += '\tpublic readonly %s %s;\n\n' % (field.cs_type(), field.name)

    return output


def build_cs_class_json_loader(class_name, fields):
    output = '\tpublic static ' + class_name + '[] CreateFromJsonArray(string json)\n'
    output += '\t{\n'
    for field in fields.values():
        output += '\t\tthis.%s = %s;\n' % (field.name, field.name)
    output += '\t}\n'
    return output


def build_cs_class(class_name, fields):
    output = '// ------------------------------------------------------ //\n'
    output += '// ----- Autogenerated by xls2json - do not modify! ----- //\n'
    output += '// ------------------------------------------------------ //\n'
    output += '\n'

    output += 'public class ' + class_name + ' : Data\n'
    output += '{\n'

    output += build_cs_class_fields(class_name, fields)

    # don't need t manually construct/load with LitJson, but may need to come
    # back to this if there are issues extending LitJson to support float/int
    # output += build_cs_class_properties(class_name, fields)
    # output += '\n'
    # output += build_cs_class_constructor(class_name, fields)
    # output += '\n'
    # output += build_cs_class_json_loader(class_name, fields)

    output += '}\n'

    return output

# verify that a file is writeable
def ensure_writeable(path, override):
    if os.path.exists(path):
        if not os.access(path, os.W_OK):
            if not override:
                print 'Error: unable to write to file %s' % path
                return False
            else:
                os.chmod(path, 644)
                print 'Warning: overriding read-only status on file %s' % path
                return True
    return True

def main():
    result = 0;

    try:
        opts, args = getopt.getopt(sys.argv[1:], '',
                                   ['source-dir=',
                                    'data-dir=',
                                    'code-dir=',
                                    'rebuild-all',
                                    'overwrite-readonly',
                                    'verbose'])
    except getopt.GetoptError as err:
        print str(err)
        sys.exit(2)

    source_dir = None
    data_dir = None
    code_dir = None
    rebuild_all = False
    overwrite_readonly = False

    for o, a in opts:
        if o == '--source-dir':
            source_dir = a
        elif o == '--data-dir':
            data_dir = a
        elif o == '--code-dir':
            code_dir = a
        elif o == '--rebuild-all':
            rebuild_all = True
        elif o == '--verbose':
            verbose = True
        elif o == '--overwrite-readonly':
            overwrite_readonly = True

    for file_path in os.listdir(source_dir):

        # get the source file name and extension
        file_name, file_ext = os.path.splitext(file_path)
        if not 'xls' in file_ext or '~$' in file_name:
            continue

        # debug
        if verbose:
            print file_name

        # output paths for data and source
        source_path = source_dir + '/' + file_path
        data_path = data_dir + '/' + file_name + '.json'
        code_path = code_dir + '/' + file_name + '.cs'

        # for determining if files need to be written
        source_time = os.path.getmtime(source_path)
        data_time = 0
        code_time = 0
        if os.path.exists(data_path):
            data_time = os.path.getmtime(data_path)
        if os.path.exists(code_path):
            code_time = os.path.getmtime(code_path)

        # read the fields and data out of the workbook
        wb = open_workbook(source_path)
        sheet = wb.sheet_by_index(0)
        fields = extract_fields(sheet)
        elements = extract_elements(sheet, fields)

        # attempt to write data
        if rebuild_all or data_time < source_time:

            # make sure we can write it
            if not ensure_writeable(data_path, overwrite_readonly):
                result = -1
                continue

            # convert row data to json
            json_data = json.dumps(elements)
            if verbose:
                print json_data

            # write it out
            data_file = open(data_path, 'w')
            data_file.write(json_data)
            data_file.close()

        # attempt to write code
        if rebuild_all or code_time < source_time:

            # make sure we can write it
            if not ensure_writeable(code_path, overwrite_readonly):
                result = -1
                continue

            # generate C# source
            cs_impl = build_cs_class(file_name, fields)
            if verbose:
                print cs_impl

            # write it out
            code_file = open(code_path, 'w')
            code_file.write(cs_impl)
            code_file.close()

    return result


if __name__ == "__main__":
    exit(main())
